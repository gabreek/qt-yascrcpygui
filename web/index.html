<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>yaScrcpy GUI - Web</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#1e1e1e">
    <meta name="mobile-web-app-capable" content="yes">
    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 1.5em; background-color: #1e1e1e; color: #d4d4d4; }
        h1, h2 { border-bottom: 1px solid #444; padding-bottom: 5px; }
        ul { list-style-type: none; padding: 0; }
        li.device-li { display: flex; justify-content: space-between; align-items: center; padding: 10px; margin: 5px 0; background-color: #2a2a2a; border-radius: 4px; cursor: pointer; }
        .device-li.selected { background-color: #007acc; }
        .device-li:not(.selected):hover { background-color: #3a3a3a; }
        button { cursor: pointer; margin-left: 5px; background-color: #007acc; color: white; border: none; border-radius: 4px; padding: 8px 12px; font-size: 14px; }
        button:hover { background-color: #005a9e; }
        .modal { display: none; position: fixed; z-index: 1; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.7); }
        .modal-content {
            background-color: #2a2a2a; /* Ensure dark background */
            position: fixed; /* Use fixed for centering */
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%); /* Centering trick */
            padding: 20px;
            border: 1px solid #555; /* Add a visible border */
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .close-btn { color: #aaa; float: right; font-size: 28px; font-weight: bold; }
        .close-btn:hover, .close-btn:focus { color: white; text-decoration: none; cursor: pointer; }
        textarea, input[type="text"] { width: 95%; padding: 8px; margin-bottom: 10px; background-color: #1e1e1e; color: #d4d4d4; border: 1px solid #555; border-radius: 4px; }
        .controls { margin-top: 1em; padding: 1em; background-color: #2a2a2a; border-radius: 4px; }
        .device-selector-container { display: flex; align-items: flex-start; margin-bottom: 1em; }
        #wifi-connect-btn { font-size: 18px; padding: 4px 10px; margin-right: 10px; }

        /* Tabs */
        .tab { overflow: hidden; border-bottom: 1px solid #444; margin-bottom: 1em; }
        .tab button { background-color: inherit; float: left; border: none; outline: none; cursor: pointer; padding: 14px 16px; transition: 0.3s; font-size: 17px; color: #d4d4d4; }
        .tab button:hover { background-color: #3a3a3a; }
        .tab button.active { background-color: #007acc; color: white; }
        .tabcontent { display: none; padding: 0; border-top: none; }

        /* Grid */
        .grid-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 1.5 em; }
        .grid-item {
            display: flex; flex-direction: column; align-items: center; text-align: center; background-color: transparent; padding: 1em; border-radius: 8px; cursor: pointer; transition: background-color 0.2s; height: 140px; /* Ensures consistent height */
        }
        .grid-item:hover { background-color: #3a3a3a; }
        .icon-container { /* New icon container styling */
            display: flex;
            justify-content: center;
            align-items: center;
            width: 64px; /* Slightly larger than the icon */
            height: 64px; /* Slightly larger than the icon */
            background-color: #363636; /* Lighter background for the icon area */
            border-radius: 12px; /* Rounded corners for the icon background */
            margin-bottom: 0.8em; /* Space between icon container and text */
        }
        .grid-item img { width: 48px; height: 48px; border-radius: 8px; /* Removed margin-bottom */ }
        .grid-item span {
            word-break: break-word; font-size: 13px; /* Slightly reduced font size */
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
            text-overflow: ellipsis; /* Optional: adds ellipsis for truncated text */
        }
        .grid-item .pkg-name { display: none; } /* Hide package name */

        /* Responsive grid */
        @media (max-width: 768px) {
            .grid-container {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 480px) {
            .grid-container {
                grid-template-columns: repeat(4, 1fr);
                gap: 0.8em;
            }
            .grid-item {
                padding: 0.5em;
            }
        }

        .grid-section-title {
            font-size: 16px; /* Larger font size for section titles */
            margin-bottom: 0.5em; /* Adjust margin for spacing */
            padding-bottom: 5px; /* Add padding-bottom to match h2 style */
            text-align: left; /* Keep text aligned left */
            border-bottom: 1px solid #444; /* Explicitly add border bottom */
        }
        .app-section-wrapper { /* Ensure sections stack vertically */
            display: block;
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>yaScrcpy Web</h1>
    <div id="devices"></div>
    <hr>


    <!-- Tabs -->
    <div class="tab">
      <button class="tablinks active" onclick="openTab(event, 'Apps')">Apps</button>
      <button class="tablinks" onclick="openTab(event, 'Winlator')">Winlator</button>
    </div>

    <!-- Tab content -->
    <div id="Apps" class="tabcontent">
      <div id="apps-grid"></div>
    </div>

    <div id="Winlator" class="tabcontent">
      <div id="winlator-grid"></div>
    </div>

    <!-- (Modals would go here, unchanged) -->
    <div id="wifi-modal" class="modal">
        <div class="modal-content">
            <span class="close-btn" id="wifi-close-btn">&times;</span>
            <h2>ADB WiFi Connect</h2>
            <input type="text" id="wifi-address-input" placeholder="IP:Port">
            <button id="wifi-connect-submit-btn">Connect</button>
            <p id="wifi-status"></p>
        </div>
    </div>

    <script>
        const devicesContainer = document.getElementById('devices');
        const deviceControlsPanel = document.getElementById('device-controls-panel');
        const appsGrid = document.getElementById('apps-grid');
        const winlatorGrid = document.getElementById('winlator-grid');

        const wifiModal = document.getElementById('wifi-modal');
        const wifiCloseBtn = document.getElementById('wifi-close-btn');
        const wifiConnectSubmitBtn = document.getElementById('wifi-connect-submit-btn');
        const wifiAddressInput = document.getElementById('wifi-address-input');
        const wifiStatus = document.getElementById('wifi-status');

        let currentDeviceId = null;
        const placeholderIcon = "/gui_assets/placeholder.png";
        const winlatorPlaceholderIcon = "/gui_assets/winlator_placeholder.png";

        wifiCloseBtn.onclick = () => wifiModal.style.display = "none";
        window.onclick = (event) => {
          if (event.target == wifiModal) wifiModal.style.display = "none";
        }

        function openTab(evt, tabName) {
            var i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tabcontent");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tablinks");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";

            if (currentDeviceId) {
                if (tabName === 'Apps') fetchApps(currentDeviceId);
                if (tabName === 'Winlator') fetchWinlatorApps(currentDeviceId);
            }
        }
        document.querySelector('.tablinks.active').click(); // Open the default tab

        async function fetchDevices() {
            devicesContainer.innerHTML = '<h2>Connected Devices:</h2>';
            const deviceListContainer = document.createElement('div');
            deviceListContainer.style.flexGrow = '1';

            const wifiBtn = document.createElement('button');
            wifiBtn.id = 'wifi-connect-btn';
            wifiBtn.textContent = 'ðŸ“¶';
            wifiBtn.title = 'ADB over WiFi';
            wifiBtn.onclick = () => { wifiModal.style.display = 'block'; };

            devicesContainer.appendChild(wifiBtn); // Append button directly
            devicesContainer.appendChild(deviceListContainer); // Append list container directly

            try {
                deviceListContainer.innerHTML = '<p>Loading devices...</p>';
                const response = await fetch('/api/devices');
                const devices = await response.json();

                if (devices.length === 0) {
                    deviceListContainer.innerHTML = '<p>No devices found.</p>';
                } else {
                    const ul = document.createElement('ul');
                    devices.forEach(device => {
                        const li = document.createElement('li');
                        li.className = 'device-li';
                        li.dataset.deviceId = device.id;
                        li.textContent = `${device.name} (${device.id})`;
                        li.onclick = () => {
                            currentDeviceId = device.id;
                            document.querySelectorAll('.device-li').forEach(item => item.classList.remove('selected'));
                            li.classList.add('selected');

                            // Fetch content for the currently active tab
                            const activeTab = document.querySelector('.tablinks.active').textContent;
                            if (activeTab === 'Apps') fetchApps(currentDeviceId);
                            if (activeTab === 'Winlator') fetchWinlatorApps(currentDeviceId);
                        };
                        ul.appendChild(li);
                    });
                    deviceListContainer.innerHTML = '';
                    deviceListContainer.appendChild(ul);

                    // Auto-select the first device and load its apps
                    if (devices.length > 0) {
                        const firstDevice = devices[0];
                        currentDeviceId = firstDevice.id;
                        const firstLi = ul.querySelector(`[data-device-id="${firstDevice.id}"]`);
                        if (firstLi) {
                            firstLi.classList.add('selected');
                            const activeTab = document.querySelector('.tablinks.active').textContent;
                            if (activeTab === 'Apps') fetchApps(currentDeviceId);
                            else if (activeTab === 'Winlator') fetchWinlatorApps(currentDeviceId);
                        }
                    }
                }
            } catch (error) {
                deviceListContainer.innerHTML = '<p>Error fetching devices.</p>';
                console.error('Fetch Devices Error:', error);
            }
        }

        function renderGrid(container, items, placeholder, launchFn) {
            container.innerHTML = '';
            if (items.length === 0) {
                container.innerHTML = '<p>No items found.</p>';
                return;
            }

            const pinnedApps = items.filter(item => item.pinned).sort((a, b) => a.name.localeCompare(b.name));
            const unpinnedApps = items.filter(item => !item.pinned).sort((a, b) => a.name.localeCompare(b.name));

            const renderSection = (title, appList) => {
                if (appList.length === 0) return;

                const sectionWrapper = document.createElement('div');
                sectionWrapper.className = 'app-section-wrapper'; // New wrapper for section title and grid

                const sectionTitle = document.createElement('h2');
                sectionTitle.textContent = title;
                sectionTitle.className = 'grid-section-title';
                sectionWrapper.appendChild(sectionTitle); // Title inside the wrapper

                const sectionGrid = document.createElement('div');
                sectionGrid.className = 'grid-container'; // Reuse grid-container styling

                appList.forEach(item => {
                    const gridItem = document.createElement('div');
                    gridItem.className = 'grid-item';
                    gridItem.onclick = () => launchFn(item);

                    const img = document.createElement('img');
                    img.src = item.icon ? `/icons/${item.icon}` : placeholder;
                    img.onerror = () => {
                        img.onerror = null; // Prevent infinite loops
                        img.src = placeholder;
                    };

                    const iconContainer = document.createElement('div');
                    iconContainer.className = 'icon-container';
                    iconContainer.appendChild(img);

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = item.name;

                    const pkgSpan = document.createElement('span');
                    pkgSpan.className = 'pkg-name';
                    pkgSpan.textContent = item.pkg_name || item.path;

                    gridItem.appendChild(iconContainer);
                    gridItem.appendChild(nameSpan);
                    gridItem.appendChild(pkgSpan);
                    sectionGrid.appendChild(gridItem);
                });
                sectionWrapper.appendChild(sectionGrid); // Grid inside the wrapper
                container.appendChild(sectionWrapper); // Append the whole wrapper
            };

            renderSection('Pinned Apps', pinnedApps);
            renderSection('All Apps', unpinnedApps);
        }

        async function fetchApps(deviceId) {
            appsGrid.innerHTML = '<p>Loading apps...</p>';
            try {
                const response = await fetch(`/api/apps?device_id=${deviceId}`);
                const apps = await response.json();
                if (apps.error) throw new Error(apps.error);
                renderGrid(appsGrid, apps, placeholderIcon, (item) => launchApp(item.pkg_name, item.name));
            } catch (error) { appsGrid.innerHTML = `<p>Error fetching apps: ${error.message}</p>`; }
        }

        async function fetchWinlatorApps(deviceId) {
            winlatorGrid.innerHTML = '<p>Loading Winlator games...</p>';
            try {
                const response = await fetch(`/api/winlator/apps?device_id=${deviceId}`);
                const games = await response.json();
                if (games.error) throw new Error(games.error);
                renderGrid(winlatorGrid, games, winlatorPlaceholderIcon, (item) => {
                    // Launching winlator apps might need a different function/endpoint
                    // For now, we'll just log it.
                    console.log("Launching Winlator game:", item);
                    alert(`Launching Winlator game: ${item.name}. (Note: Launch logic not fully implemented in web UI yet)`);
                });
            } catch (error) { winlatorGrid.innerHTML = `<p>Error fetching games: ${error.message}</p>`; }
        }

        wifiConnectSubmitBtn.onclick = async () => {
            const address = wifiAddressInput.value.trim();
            if (!address) return;
            wifiStatus.textContent = `Connecting to ${address}...`;
            try {
                const response = await fetch('/api/adb/connect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ address: address })
                });
                const result = await response.json();

                wifiStatus.textContent = result.message;
                if (result.status === 'success') {
                    setTimeout(() => {
                        wifiModal.style.display = 'none';
                        fetchDevices();
                    }, 1500);
                }
            } catch (error) {
                wifiStatus.textContent = 'An error occurred.';
                console.error('WiFi Connect Error:', error);
            }
        };

        async function launchApp(pkgName, appName) {
            if (!currentDeviceId) { alert('Please select a device first.'); return; }
            try {
                await fetch('/api/launch', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ device_id: currentDeviceId, pkg_name: pkgName, app_name: appName })
                });
            } catch (error) { alert('Failed to send launch command.'); }
        }


        document.querySelectorAll('.key-btn').forEach(button => { /* Unchanged */ });

        fetchDevices();
    </script>
</body>
</html>
